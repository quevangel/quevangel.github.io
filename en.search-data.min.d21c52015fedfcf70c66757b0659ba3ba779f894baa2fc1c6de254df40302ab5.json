[{"id":0,"href":"/docs/","title":"Docs","section":"","content":" Sobre este sitio # Este es un sitio dedicado al estudio de la programación competitiva con un enfoque heurístico.\n"},{"id":1,"href":"/docs/gxlois/","title":"Gxlois","section":"Docs","content":"Notas de Gxlois.\n"},{"id":2,"href":"/docs/gxlois/metodo-analitico/","title":"Método Analítico","section":"Gxlois","content":" Sobre el método analítico # El método analítico es la manera en que propongo estudiar y mejorar la manera de abordar problemas en la programación competitiva.\nEn mi práctica, he notado que existen dos principales procesos involucrados en el proceso de pensamiento que lleva a una solución:\nAnálisis. La parte matemática/observacional. El proceso durante el cuál se obtienen observaciones. Hechos relevantes sobre el problema o sus elementos que justifican o hacen posible una solución. Suelen consistir en restricciones, relaciones algebraicas, simplificaciones, equivalencias lógicas, descomposiciones, etc.\nSíntesis. La parte algorítmica/propositiva. El proceso durante el cuál se producen propuestas algorítimicas. Consiste tanto en la definición de un algoritmo tal cuál así como la definición de sus partes: Descomposición del problema de cómputo original en subproblemas, propuesta del uso de alguna técnica computacional particular (como programación dinámica, el uso de alguna estructura de datos, etc.).\nComo ejemplo de cómo estos dos elementos de la solución de un problema juegan entre sí presento un problema simple y bastante conocido: Dado $N$ calcular $1 + 2 + 3 \u0026hellip; + N$.\nExisten dos soluciones conocidas diamétricamente opuestas a este problema: Una compuesta principalmente por síntesis, y la otra compuesta principalmente por análisis.\nPodemos hacer un mínimo de análisis y darnos cuenta que podemos iterativamente calcular: 0, 0 + 1, 0 + 1 + 2, 0 + 1 + 2 + 3, etc. usando una estructura de iteración simple.\nint n; std::cin \u0026gt;\u0026gt; n; int suma = 0; for (int i = 1; i \u0026lt;= n; i++) { suma += i; } std::cout \u0026lt;\u0026lt; suma \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Esto nos da una solución de complejidad $O(N)$. Esta es una solución esencialmente \u0026ldquo;sintética\u0026rdquo;.\nDel lado opuesto, podemos hacer primero un análisis puramente matemático del problema. Y así percatarnos de que existe una expresión simple equivalente al problema original (la manera de llegar a esta expresión no es el enfoque de éste artículo): $1 + 2 + 3 \u0026hellip; + N = \\frac{N (N + 1)}{2}$.\nLa síntesis algorítmica que surge de esta observación es bastante directa:\nint n; std::cin \u0026gt;\u0026gt; n; int suma = n * (n + 1) / 2; std::cout \u0026lt;\u0026lt; suma \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; Esto nos da una solución de complejidad temporal $O(1)$. Esta es una solución esencialmente \u0026ldquo;analítica\u0026rdquo;.\n"}]